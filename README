C/C++ parser for the CSP XML format version 3.0

(c) 2015 xcp3.org (contact <at> xcsp3.org)
(c) 2008 olivier.roussel at cril.univ-artois.fr



The files in this archive containt a C++ parser for the XML format of
CSP/WCSP instances named XCSP 3.0. 

This parser uses the libxml2 library which must be installed on your
system

See http://xmlsoft.org/

This library is probably installed on most Linux platforms. Note that
you'll need both the libxml2 and the libxml2-devel packages to compile
your program.

The proposed parser reads the XML file in SAX mode. That means that
each time an XML tag is read, the libxml2 library calls a function of
the parser. In turn, the parser will decode the XML information and
call a function of the solver to transmit the informations that were
read.

The advantage of the SAX mode is that it doesn't use much memory. Its
drawback is that it forces to read the information in the order of
the XML file. In contrast, the DOM model would allow reading the
informations in any order but would require to store the whole XML
file in memory before the solver can grab any information.


Here's how the parser interfaces with the solver. The author of a
solver writes an interface (a set of functions) which are called by
the parser when it decodes a piece of information from the XML file
(this is a callback). These interface functions are in charge of
populating the data structures used by the solver. They don't have to
cope with the XML details (only the parser does). This is in fact an
instance of the Builder Design Pattern
(http://www.developer.com/design/article.php/1502691)

The programmer simply calls the parser with the file to read and with
a reference to the callback functions to use. The parser reads the
file, decodes the information and calls the callback functions that
create the solver data structures. Once the parser is done, the solver
can start its quest of a solution.

Let's take an example to give a clear idea of how it can work:

1) the solver calls the parser

2) the parser reads the XML file, chunk by chunk

3) when the parser reads the <instance> tag, it calls the solver
function beginInstance(). When the parser reads the </instance> tag, 
it calls the function endInstance()

4) It does the same calls for tags <variables> and <constraints>


5) when the parser reads the <var> tag, it calls the solver function
newVar(XVariable* var). The XVariable* contains all informations needed to 
create this variable.

6) the same occurs for each type of constraint, with the dedicated 
call to newConstraintXXX where XXX is either Extension, Intension....

7) Note that the constraint is free'd after this call.


and so on...


#
# Inner working of the parser
#

In a few words, the class XCSP3CorePArser<> is the main class, which
contains the parse() method. It has a template which is the type of
the callback class to use. By default, this template argument is
CSPParserCallback which defines the virtual methods which the parser
will call to provide the solver with the decoded information. If you
think that virtual functions are evil, you can instanciate
XCSP3CoreParser<Callback> with a callback class that doesn't use
virtual functions (but the parser still uses virtual methods in a
number of other classes).

XCSP3CoreParser is mainly an interface between the libxml2 library
and the XMLParser class which contains the actual parser.

All Domain types (ranges or integer values) are in XDomain.h, they are stored as 
they are represented in XCSP3 format.
All Variable types are in XVariable.h
All Constraint are in XConstraint.h. they contains attributes named wrt XCSP3 specifications
(list, values, index...)
The objective (if it exists) is in XObjective.h

Some notes on these classes:
XDomain.h
   * An IntegerEntity is either a IntegerValue (5) or an IntegerInterval (6..9)
   * A XDomain contains a vector of IntegerEntity

XVariable.h
   * Class XEntity represents all possible entries for contraints: Variable, 
     integers, parameters...
   * XVariable is the class that represents a CSP variable with its id, domain 
     and so on
   * XVariableArray corresponds to an array of variables, all variable of this array 
     are created and stored in the member variables.
   * XparameterVariable is used in a group, it is either  %0, %1.. %... etc
   * XInteger is a fake variable used to store an integer in lists where a 
     variable or an integer are allowed
   * function isIntegerVariable can be used to check and retrieve if a XVariable is 
     really an integer
   

XConstraints.h
   * Classes used to stored each type of constraint:XConstraintExtension, XConstraintAllDiff...
   * All constraints contain fields that named with names used in XCSP3 format.

XObjectives.h
   * Class used to stored an objective 

XConstants.h
   * Constants (usually enum types) used during the parsing process. Useful to know 
     some operators, type of grouping...
 
